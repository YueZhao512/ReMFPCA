#' A Class of Multivariate Multidimensional Basis Functions
#'
#' @description
#' The `mvbasismfd` class represents functional data ...
#'
#' An object of class "mvbasismfd" is a list containing the following elements:
#' @field nvar description
#' @field basis A list of mvbasisfd objects
#' @field dimSupp A sequence of positive integers specifying the dimension...
#' @field nbasis A list of integers specifying the number of basis functions...
#' @field supp A list of matrices specifying the support of basis functions...
#' @field gram A block diagonal matrix
#'
#'
#' @examples
#' x <- 1
#'
#' @importFrom fda is.basis eval.basis
#' @importFrom Matrix Matrix bdiag
#'
#' @export
mvbasismfd <- R6::R6Class("mvbasismfd",
  public = list(
    #' @param basis A list of `basismfd` objects
    initialize = function(basis) {
      if (is.basis(basis) | is.basismfd(basis)) basis <- list(basis)
      init_mvbasismfd_check(basis)
      private$.nvar <- length(basis)
      private$.gram <- bdiag()
      for (i in 1:private$.nvar) {
        if (is.basis(basis[[i]])) {
          basis[[i]] <- basismfd$new(basis[[i]])
        } else {
          basis[[i]] <- basis[[i]]$clone()
        }
        private$.dimSupp[i] <- basis[[i]]$dimSupp
        private$.nbasis[[i]] <- basis[[i]]$nbasis
        private$.supp[[i]] <- basis[[i]]$supp
        private$.gram <- bdiag(private$.gram, basis[[i]]$gram)
      }
      private$.basis <- basis
    },

    #' Evaluate the `mvbasismfd` object at given argument values
    #'
    #' @param evalarg A list of numeric vectors of argument values at which the `basismfd` is to be evaluated
    #' @return A list of evaluated values
    eval = function(evalarg) {
      eval_mvbasismf_validity_check(evalarg, private$.nvar)
      if (is.numeric(evalarg)) {
        evalarg <- list(list(evalarg))
      }
      out <- list()
      for (i in 1:length(evalarg)) {
        out[[i]] <- private$.basis[[i]]$eval(evalarg[[i]])
      }
      return(out)
    }
  ),
  active = list(
    # nvar field
    nvar = function(value) {
      if (missing(value)) {
        private$.nvar
      } else {
        stop("`$nvar` is read only", call. = FALSE)
      }
    },

    # basis field
    basis = function(value) {
      if (missing(value)) {
        private$.basis
      } else {
        stop("`$basis` is read only", call. = FALSE)
      }
    },

    # dimSupp field
    dimSupp = function(value) {
      if (missing(value)) {
        private$.dimSupp
      } else {
        stop("`$dimSupp` is read only", call. = FALSE)
      }
    },

    # nbasis field
    nbasis = function(value) {
      if (missing(value)) {
        private$.nbasis
      } else {
        stop("`$nbasis` is read only", call. = FALSE)
      }
    },

    # supp field
    supp = function(value) {
      if (missing(value)) {
        private$.supp
      } else {
        stop("`$supp` is read only", call. = FALSE)
      }
    },

    # gram field
    gram = function(value) {
      if (missing(value)) {
        private$.gram
      } else {
        stop("`$gram` is read only", call. = FALSE)
      }
    }
  ),
  private = list(
    .nvar = NULL,
    .basis = NULL,
    .dimSupp = NULL,
    .nbasis = list(),
    .supp = list(),
    .gram = NULL
  )
)

# Function to check the validity of initializer
init_mvbasismfd_check <- function(basis) {
  if (is.list(basis)) {
    if (!all(sapply(basis, function(x) {
      return(is.basis(x) | is.basismfd(x))
    }))) {
      stop("All the elements of basis list must be basisfd or basismfd object.")
    }
  }
}

# Function to check the validity of evaluation
eval_mvbasismf_validity_check <- function(evalarg, nvar) {
  if (!is.list(evalarg) & !is.numeric(evalarg)) {
    stop("evalarg must be a list or numeric vector")
  }
  if (is.numeric(evalarg)) {
    if (nvar != 1) {
      stop("evalarg is allowed to be a numeric if nvar = 1.")
    } else {
      evalarg <- list(list(evalarg))
    }
  }
  if (!all(sapply(evalarg, function(x) is.numeric(x) | is.list(x)))) {
    stop("evalarg list elements must be a list or numeric vector")
  }
  if (length(evalarg) != nvar) {
    stop("length of evalarg is not equal to nvar.")
  }
}

#' Constructor for mvbasismfd objects
#'
#' @param basis A list of basisfd objects
#'
#' @export
Mvbasismfd <- function(basis) mvbasismfd$new(basis)
