onedG <- function(A, B, grid, method = "trapezoidal") {
M <- nrow(grid)
dx <- grid[2] - grid[1]
if (method == "rectangular") {
G <- dx * t(B) %*% A
} else {
D_diag <- c(1, rep(x = 2, (M - 2)), 1)
D <- matrix(data = 0, nrow = M, ncol = M)
diag(D) <- D_diag
G <- (dx / 2) * t(B) %*% D %*% A
}
return(G)
}
A=B
grid=grids
M <- nrow(grid)
M
grids <- matrix(seq(0,1,length.out=100))
grids
B <- splines::bs(grids,df=10)[,]
B
ReFPCA:::onedG(A=B,B=B,grid=grids)
library(ReFPCA)
library(ReFPCA)
a <- "a"
b <- "b"
c <- "c"
class(a) <- "myC"
class(b) <- "yourC"
class(c) <- "theirC"
c
c <- list(a,b)
c
c$a
c[[1]]
c[[2]]
class(a)
class(c)
class(c) <- "theirC"
class(c)
class(c$a)
c <- list(a=a,b=b)
a$a
c$a
c
class(c)
class(c) <- "theirC"
class(c)
class(c$a)
class(c$b)
class(c$b) <- "res"
class(c$b)
Mres <- "a"; class(Mres) <- "profile"
res <- "b"; class(res) <- "res"
RA_gwid <- list(res=res, Mres=Mres); class(RA_gwid) <- "gwid"
RA_gwid
class(RA_gwid)
view(density)
edit(density)
density.default()
edit(density.default())
edit(density.default)
density.default
install.packages("kdensity")
library("kdensity")
?kdensity
concentration = Theoph$conc + 0.001
plot(kdensity(concentration, start = "gamma", kernel = "gamma", adjust = 1/3),
ylim = c(0, 0.15), lwd = 2, main = "Concentration of theophylline")
?kernel
t = list( kernel = function(y, x, h) stats::dt((y-x)/h), df = 1, support = c(-Inf, Inf) )
t
concentration = Theoph$conc + 0.001
plot(kdensity(concentration, kernel = "gaussian", adjust = 1/3),
ylim = c(0, 0.15), lwd = 2, main = "Concentration of theophylline")
concentration = Theoph$conc + 0.001
plot(kdensity(concentration, kernel = "t", adjust = 1/3),
ylim = c(0, 0.15), lwd = 2, main = "Concentration of theophylline")
edit(density.default())
edit(density.default
)
density.default()
density.default
dt
?dt
tdensity <- function (x, bw = "nrd0", adjust = 1, kernel = c("gaussian",
"epanechnikov", "rectangular", "triangular",
"biweight", "cosine", "optcosine"), weights = NULL,
window = kernel, width, give.Rkern = FALSE, n = 512, from,
to, cut = 3, na.rm = FALSE, ...)
{
chkDots(...)
if (!missing(window) && missing(kernel))
kernel <- window
kernel <- match.arg(kernel)
if (give.Rkern)
return(switch(kernel, gaussian = 1/(2 * sqrt(pi)), rectangular = sqrt(3)/6,
triangular = sqrt(6)/9, epanechnikov = 3/(5 * sqrt(5)),
biweight = 5 * sqrt(7)/49, cosine = 3/4 * sqrt(1/3 -
2/pi^2), optcosine = sqrt(1 - 8/pi^2) * pi^2/16))
if (!is.numeric(x))
stop("argument 'x' must be numeric")
name <- deparse1(substitute(x))
x <- as.vector(x)
x.na <- is.na(x)
if (any(x.na)) {
if (na.rm)
x <- x[!x.na]
else stop("'x' contains missing values")
}
N <- nx <- as.integer(length(x))
if (is.na(N))
stop(gettextf("invalid value of %s", "length(x)"),
domain = NA)
x.finite <- is.finite(x)
if (any(!x.finite)) {
x <- x[x.finite]
nx <- length(x)
}
if (is.null(weights)) {
weights <- rep.int(1/nx, nx)
totMass <- nx/N
}
else {
if (length(weights) != N)
stop("'x' and 'weights' have unequal length")
if (!all(is.finite(weights)))
stop("'weights' must all be finite")
if (any(weights < 0))
stop("'weights' must not be negative")
wsum <- sum(weights)
if (any(!x.finite)) {
weights <- weights[x.finite]
totMass <- sum(weights)/wsum
}
else totMass <- 1
if (!isTRUE(all.equal(1, wsum)))
warning("sum(weights) != 1  -- will not get true density")
}
n.user <- n
n <- max(n, 512)
if (n > 512)
n <- 2^ceiling(log2(n))
if (missing(bw) && !missing(width)) {
if (is.numeric(width)) {
fac <- switch(kernel, gaussian = 4, rectangular = 2 *
sqrt(3), triangular = 2 * sqrt(6), epanechnikov = 2 *
sqrt(5), biweight = 2 * sqrt(7), cosine = 2/sqrt(1/3 -
2/pi^2), optcosine = 2/sqrt(1 - 8/pi^2))
bw <- width/fac
}
if (is.character(width))
bw <- width
}
if (is.character(bw)) {
if (nx < 2)
stop("need at least 2 points to select a bandwidth automatically")
bw <- switch(tolower(bw), nrd0 = bw.nrd0(x), nrd = bw.nrd(x),
ucv = bw.ucv(x), bcv = bw.bcv(x), sj = , `sj-ste` = bw.SJ(x,
method = "ste"), `sj-dpi` = bw.SJ(x,
method = "dpi"), stop("unknown bandwidth rule"))
}
if (!is.finite(bw))
stop("non-finite 'bw'")
bw <- adjust * bw
if (bw <= 0)
stop("'bw' is not positive.")
if (missing(from))
from <- min(x) - cut * bw
if (missing(to))
to <- max(x) + cut * bw
if (!is.finite(from))
stop("non-finite 'from'")
if (!is.finite(to))
stop("non-finite 'to'")
lo <- from - 4 * bw
up <- to + 4 * bw
y <- .Call(C_BinDist, x, weights, lo, up, n) * totMass
kords <- seq.int(0, 2 * (up - lo), length.out = 2L * n)
kords[(n + 2):(2 * n)] <- -kords[n:2]
kords <- switch(kernel, gaussian = bw*dt(kords, df = 5),
rectangular = {
a <- bw * sqrt(3)
ifelse(abs(kords) < a, 0.5/a, 0)
}, triangular = {
a <- bw * sqrt(6)
ax <- abs(kords)
ifelse(ax < a, (1 - ax/a)/a, 0)
}, epanechnikov = {
a <- bw * sqrt(5)
ax <- abs(kords)
ifelse(ax < a, 3/4 * (1 - (ax/a)^2)/a, 0)
}, biweight = {
a <- bw * sqrt(7)
ax <- abs(kords)
ifelse(ax < a, 15/16 * (1 - (ax/a)^2)^2/a, 0)
}, cosine = {
a <- bw/sqrt(1/3 - 2/pi^2)
ifelse(abs(kords) < a, (1 + cos(pi * kords/a))/(2 *
a), 0)
}, optcosine = {
a <- bw/sqrt(1 - 8/pi^2)
ifelse(abs(kords) < a, pi/4 * cos(pi * kords/(2 *
a))/a, 0)
})
kords <- fft(fft(y) * Conj(fft(kords)), inverse = TRUE)
kords <- pmax.int(0, Re(kords)[1L:n]/length(y))
xords <- seq.int(lo, up, length.out = n)
x <- seq.int(from, to, length.out = n.user)
structure(list(x = x, y = approx(xords, kords, x)$y, bw = bw,
n = N, call = match.call(), data.name = name, has.na = FALSE),
class = "density")
}
plot(density(c(-20, rep(0,98), 20)), xlim = c(-4, 4))  # IQR = 0
plot(tdensity(c(-20, rep(0,98), 20)), xlim = c(-4, 4))  # IQR = 0
tdensity
plot(tdensity(c(-20, rep(0,98), 20)), xlim = c(-4, 4))  # IQR = 0
bandwidth.nrd(x)
bandwidth.nrd
bandwidth.nrd()
?bandwidth.nrd()
stats::bandwidth.kernel()
bandwidth.kernel
?bandwidth.kernel
bw.nrd(rnorm(100))
kde <- function (x, h, n = 25, lims = range(x)) {
nx <- length(x)
if (any(!is.finite(x))) stop("missing or infinite values in the data are not allowed")
if (any(!is.finite(lims))) stop("only finite values are allowed in 'lims'")
gx <- seq.int(lims[1L], lims[2L], length.out = n)
h <- if (is.null(h)) bw.nrd(x)
ax <- outer(gx, x, "-")
ax <- ax/h
z <- dt(ax,20)/(nx * h[1L])
list(x = gx, z = z)
}
kde(rnorm(100))
kde(rnorm(100),h=NULL)
dim(kde(rnorm(100),h=NULL))
kde(rnorm(100),h=NULL)
a <- kde(rnorm(100),h=NULL)
a
ax
x
x <- rnorm(100)
h=NULL
n = 25
lims = range(x)
nx <- length(x)
if (any(!is.finite(x))) stop("missing or infinite values in the data are not allowed")
if (any(!is.finite(lims))) stop("only finite values are allowed in 'lims'")
gx <- seq.int(lims[1L], lims[2L], length.out = n)
gx
h <- if (is.null(h)) bw.nrd(x)
h
ax <- outer(gx, x, "-")
ax
gx
?tcrossprod
z
ax
h <- if (is.null(h)) bw.nrd(x)
ax <- outer(gx, x, "-")
ax <- ax/h
ax
gx
x
ax <- outer(gx, x, "-")
ax
ax/h
ax
ax
h
h <- if (is.null(h)) bw.nrd(x)
h
ax <- outer(gx, x, "-")
ax
ax <- ax/h
ax
z <- dt(ax,20)/(nx * h[1L])
z
apply(z,1,sum)
ts.plot(apply(z,1,sum))
kde <- function (x, h=NULL, n = 25, lims = range(x)) {
nx <- length(x)
if (any(!is.finite(x))) stop("missing or infinite values in the data are not allowed")
if (any(!is.finite(lims))) stop("only finite values are allowed in 'lims'")
gx <- seq.int(lims[1L], lims[2L], length.out = n)
h <- if (is.null(h)) bw.nrd(x)
ax <- outer(gx, x, "-")
ax <- ax/h
z <- dt(ax,20)/(nx * h[1L])
list(x = gx, z = apply(z,1,sum))
}
kde(rnorm(x))
plot(kde(rnorm(x)))
dens <- kde(x)
plot(dens$x,dens$z,type="l")
dens <- kde(x)
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
kde <- function (x, h=NULL, n = 25, lims = range(x)) {
nx <- length(x)
if (any(!is.finite(x))) stop("missing or infinite values in the data are not allowed")
if (any(!is.finite(lims))) stop("only finite values are allowed in 'lims'")
gx <- seq.int(lims[1L], lims[2L], length.out = n)
h <- if (is.null(h)) bw.nrd(x)/4
ax <- outer(gx, x, "-")
ax <- ax/h
z <- dt(ax,20)/(nx * h[1L])
list(x = gx, z = apply(z,1,sum))
}
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
kde <- function (x, h=NULL, n = 25, lims = range(x)) {
nx <- length(x)
if (any(!is.finite(x))) stop("missing or infinite values in the data are not allowed")
if (any(!is.finite(lims))) stop("only finite values are allowed in 'lims'")
gx <- seq.int(lims[1L], lims[2L], length.out = n)
h <- if (is.null(h)) bw.nrd(x)
ax <- outer(gx, x, "-")
ax <- ax/h
z <- dt(ax,20)/(nx * h[1L])
list(x = gx, z = apply(z,1,sum))
}
dens <- kde(rnorm(1000))
plot(dens$x,dens$z,type="l")
kde <- function (x, h=NULL, n = 25, lims = range(x)) {
nx <- length(x)
if (any(!is.finite(x))) stop("missing or infinite values in the data are not allowed")
if (any(!is.finite(lims))) stop("only finite values are allowed in 'lims'")
gx <- seq.int(lims[1L], lims[2L], length.out = n)
h <- if (is.null(h)) bw.nrd(x)
ax <- outer(gx, x, "-")
ax <- ax/h
z <- dt(ax,20)/(nx * h[1L])
list(x = gx, z = apply(z,1,sum))
}
dens <- kde(rnorm(1000))
dens <- kde(rnorm(1000))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(1000))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
kde <- function (x, h=NULL, n = 25, lims = range(x)) {
nx <- length(x)
if (any(!is.finite(x))) stop("missing or infinite values in the data are not allowed")
if (any(!is.finite(lims))) stop("only finite values are allowed in 'lims'")
gx <- seq.int(lims[1L], lims[2L], length.out = n)
h <- if (is.null(h)) bw.nrd(x)
ax <- outer(gx, x, "-")
ax <- ax/h
z <- dnorm(ax)/(nx * h[1L])
list(x = gx, z = apply(z,1,sum))
}
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
dens <- kde(rnorm(100))
plot(dens$x,dens$z,type="l")
library(imager)
y <- list(); Y <- NULL;
fing <- grayscale(load.image("finger.jpg"))
setwd("C:/Dropbox/Marquette/Course/MSSC6250/Labs/PCA")
fing <- grayscale(load.image("finger.jpg"))
dim(fing)
image(fing)
image(fing[,,11])
image(fing[,,1,1])
library(imager)
y <- list(); Y <- NULL;
fing <- grayscale(load.image("finger.jpg"))[,,1,1]
image(fing)
dim(fing)
persp(fing)
filled.contour(fing)
svd.fing <- svd(fing)
dim(svd.fing)
svd.fing$d
qr(fing)$rank
rec.fing <- svd.fing$u[,1:k]%*%diag(svd.fing$d[1:k])%*%t(svd.fing$v[,1:k])
k <- 128
rec.fing <- svd.fing$u[,1:k]%*%diag(svd.fing$d[1:k])%*%t(svd.fing$v[,1:k])
range(rec.fing-fing)
all.equal(rec.fing,fing)
qr(rec.fing)$rank
filled.contour(rec.fing)
k <- 10
rec.fing <- svd.fing$u[,1:k]%*%diag(svd.fing$d[1:k])%*%t(svd.fing$v[,1:k])
all.equal(rec.fing,fing)
qr(rec.fing)$rank
filled.contour(rec.fing)
fing <- grayscale(load.image("chess.bmp"))[,,1,1]
dim(fing)
filled.contour(fing)
library(imager)
img <- grayscale(load.image("chess.bmp"))[,,1,1]
dim(img)
image(img)
svd.img <- svd(img)
dim(svd.img$u)
dim(svd.img$v)
svd.img$d
qr(img)$rank
k <- 2
rec.img <- svd.img$u[,1:k]%*%diag(svd.img$d[1:k])%*%t(svd.img$v[,1:k])
all.equal(rec.img,img)
qr(rec.img)$rank
filled.contour(rec.img)
gc()
library(imager)
img <- grayscale(load.image("finger.jpg"))[,,1,1]
dim(img)
range(img)
image(img,main="observed image")
filled.contour(img)
svd.img <- svd(img)
dim(svd.img$u)
dim(svd.img$v)
svd.img$d
qr(img)$rank
plot(svd.img$d)
cumsum(svd.img$d)
cumsum(svd.img$d)/sum(svd.img$d)
k <- 128
rec.img <- svd.img$u[,1:k]%*%diag(svd.img$d[1:k])%*%t(svd.img$v[,1:k])
all.equal(rec.img,img)
image(rec.img,main="reconstructed image")
k <- 40
dim(svd.img$u[,1:k])
dim(svd.img$u)
rec.img <- svd.img$u[,1:k]%*%diag(svd.img$d[1:k])%*%t(svd.img$v[,1:k])
dim(rec.img)
all.equal(rec.img,img)
qr(rec.img)$rank
image(rec.img,main="reconstructed image")
dim(svd.img$u)
dim(svd.img$u[,1:k])
dim(svd.img$v[,1:k])
128*128
128*40*2+40
img <- grayscale(load.image("chess.bmp"))[,,1,1]
dim(img)
768*768
image(img,main="observed image")
svd.img <- svd(img)
dim(svd.img$u)
dim(svd.img$v)
svd.img$d
qr(img)$rank
k <- 2
k <- 2
svd.img$u[,1:k]
svd.img$v[,1:k]
diag(svd.img$d[1:k])
rec.img <- svd.img$u[,1:k]%*%diag(svd.img$d[1:k])%*%t(svd.img$v[,1:k])
dim(rec.img)
all.equal(rec.img,img)
qr(rec.img)$rank
image(rec.img,main="reconstructed image")
768*768
768*2*2+2
3074/768*768
3074/(768*768)
range(img)
n.img <- img + rnorm(768*768,sd=0.1)
image(n.img)
svd.img <- svd(n.img)
svd.img$d
k <- 2
rec.img <- svd.img$u[,1:k]%*%diag(svd.img$d[1:k])%*%t(svd.img$v[,1:k])
all.equal(rec.img,img)
qr(rec.img)$rank
image(rec.img,main="reconstructed image")
outer(seq(0.75, 1.25, length.out = 11), sin(argvals))
argvals <- seq(0,2*pi,0.01)
argvals <- seq(0,2*pi,0.01)
outer(seq(0.75, 1.25, length.out = 11), sin(argvals))
dim(outer(seq(0.75, 1.25, length.out = 11), sin(argvals))_
dim(outer(seq(0.75, 1.25, length.out = 11), sin(argvals)))
matplot
A=outer(seq(0.75, 1.25, length.out = 11), sin(argvals))
matplot(A)
matplot(t(A))
?outer
seq(0.75, 1.25, length.out = 11)
install.packages('hrbrthemes')
installed.packages('fda')
install.packages('plotly')
